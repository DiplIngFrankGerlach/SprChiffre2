

class ThreadInfo multithreaded
{
   
   longlong _threadID; 
methods:
   ThreadInfo();
   external longlong getThreadID();
   external void join();
   external void  threadMain();
};

 
/* class for easy and safe printing, similar(but more secure) as printf() in C */
class PrintfClass 
{
   String_16 _fstr;
   String_128 _outBuf;
   int _fstrIdx;
   *char bufferDyn[];
methods:
   //set the format string
   //arguments are specified using the dollar ($) sign
   &PrintfClass fstr(&char str[]);
   
   //set a string argument
   &PrintfClass sa(&char str[]);

   //set an integer argument
   &PrintfClass sa(int num);

   //set an integer argument with base and character width
   &PrintfClass sa(int num,int base, int numChars);

   &PrintfClass sa(longlong num);

   &PrintfClass saHex(char oktet);

   &PrintfClass saHex(longlong number);

   &PrintfClass saHex(int number);
   
   //set a double argument
   &PrintfClass sa(double num);
   
   //set a float argument
   &PrintfClass sa(float num);
   
   //set a String_16 argument
   &PrintfClass sa(&String_16 str);
   
   //set a String_16 argument
   &PrintfClass sa(String_16* str);
   
   
   
   &PrintfClass sa(*char str[]);
   
   &PrintfClass sa(char c);
   
   &PrintfClass saExp(double num);
      
   //actually print the string to the console
   void pr();
   
   //print a verbatim string immediately
   void pr(&char text[]);
   
   void prNoLF();
   //void threadMain();    

    
   void prHex(char x);
   
   PrintfClass();
};

class Umgebung
{
methods:
   static void leseVariable(&String_16 varName,&int erfolg,&String_16 wert);
	
	int leseVariable(&char varName[],&String_16 wertStr);
};

enum SPRFile_Mode { SF_Readonly, SF_ReadWrite, SF_ReadWriteTruncated };


class SPRFile
{
   int _handle;
   *char _readBuffer[];
   int _readPtr;
   int _validBytes;
   int _fpos;
methods:
   //open a file specified by path
   SPRFile(&char path[], int readonly);

   SPRFile(&String_16 pfad, int readonly);

   SPRFile();

   int oeffne(&String_16 dateiName,SPRFile_Mode modus);

   int oeffne(&char path[], int readonly,int neueLoeschen);

   //get the system file handle. A negative value normally indicates
   //that the file could not be created/openend
   int systemHandle();
   //read 'count' bytes from position 'pos' in the file
   //returns the number of bytes actually read into the buffer
   int read(int pos,int count,&char buffer[]);   
   int read(int pos,int count,*char buffer[]);   
   
   //write 'count' bytes at position 'pos' into 'buffer'
   //returns the number of bytes actually written
   int write(int pos,int count,&char buffer[]);
   int write(int pos,int count,*char buffer[]);

   int write64(longlong pos,int count,&char buffer[]);

   int schreibeAlles(*char buffer[],int stelleEingabe, int stelleAusgabe, int anzahl);
   
   //get the current size of the file
   int size();
   //close the file. This is implicitly done upon the destruction 
   //of this object
   void close();
   
   int readLine(&String_16 oLine);
   int readChar(&char out);
   
   ~SPRFile();
   
   ///INTERNAL TEST METHODS
   static void UnitTest();
};

class Logfile extends SPRFile
{
    int writePos;
    *char buffer[];
methods:
    Logfile(&String_16 filename);
    int append(&String_16 traceMessage);
};


class ThreadLocalStorageList{
   inline_cpp[[
      char* _stackStartPtr;
   ]]
   int _entryCount;
   ThreadLocalStorageEntry* _entries[1000];
   methods:
   //ThreadLocalStorageList();
};

class ThreadLocalStorageEntry{
    int _id;
    int _dummy;
   methods:
};

class ThreadLocalStorage{
     ThreadLocalStorageEntry* _entries[1000];
   methods:
     //static int allocateEntry();
     static void getEntry(int id,&ThreadLocalStorageEntry* ret);
     static void setEntry(int id,ThreadLocalStorageEntry* entry);
};

class SystemTime
{
methods:
  //get current time in milliseconds
  longlong getMillisecondCounter();
  void getDateTimeString(&String_16 dateTimeStringNOW);
};

class CommandlineArgs
{
methods:
   int numberOfArguments();
   void getArgument(int idx,&String_16 arg);
   void getArgument(int idx,&int arg);
};

class SystemConstants
{
   methods:
    SystemConstants();
    char getFileSeparator(); 
    int isWindows();
    int isUnix();
};

class SystemControl{
 methods:
   SystemControl();
   void exit();

   void uSleep(int microSeconds);

   static void exitError(&char message[]);

};

class HexPrinter{
  methods:
    void intToHex(int x,&char out[],int startIndex);
};





generative_function[GrowingList](ElementType)
[[ 
 
class GrowingList_@ElementType@
{ 
     *@ElementType@* _elements[];
     int _numUsed; 
      
 
methods: 
    GrowingList_@ElementType@(int initialSize);
    void add(@ElementType@* x);

    //next three methods are for Stack-Style operation
    void push(@ElementType@* x);
    void pop(&@ElementType@* x);
    void peek(&@ElementType@* x);

    void getAt(int idx,&@ElementType@* x);
    int length();
};    
 
]] 
 
[[    
GrowingList_@ElementType@::GrowingList_@ElementType@(int initialSize)
{
  _numUsed=0;
  _elements=new @ElementType@*[initialSize];
}

void GrowingList_@ElementType@::add(@ElementType@* x)
{
   if(_numUsed==_elements.sz)
   {
      var *@ElementType@* newList[];
      newList=new @ElementType@*[_numUsed*2+2];
      for(var int i=0;i<_elements.sz;i++)
      {
         newList[i]=_elements[i];
      }
      _elements=newList;
   }       
   _elements[_numUsed]=x;
   _numUsed++;
}

void GrowingList_@ElementType@::push(@ElementType@* x)
{
   this.add(x);
}

void GrowingList_@ElementType@::pop(&@ElementType@* x)
{
   if( _numUsed > 0)
   {
       x = _elements[_numUsed - 1];
       _elements[_numUsed - 1] = NULL;
       _numUsed = _numUsed - 1;
   }
   else
   {
      var PrintfClass pfc;
      pfc.fstr("Stack is empty in GrowingList_@ElementType@::pop").pr();
      var SystemControl sc;
      sc.exit(); 
   } 
}

void GrowingList_@ElementType@::peek(&@ElementType@* x)
{
   if( _numUsed > 0)
   {
       x = _elements[_numUsed - 1];
   }
   else
   {
      var PrintfClass pfc;
      pfc.fstr("Stack is empty in GrowingList_@ElementType@::peek").pr();
      var SystemControl sc;
      sc.exit(); 
   } 
}

void GrowingList_@ElementType@::getAt(int idx,&@ElementType@* x)
{
   if(idx<_numUsed)
   {
      x=_elements[idx];
   }
}

int GrowingList_@ElementType@::length()
{
   return _numUsed;
}

]] 


class KeyType4{
    String_16 _vornameNamename;
  methods:
    KeyType4(&String_16 vornameNachname);
    KeyType4(&char vornameNachname[]);
    
    int compare(&KeyType4 other);
    int getHashCode();
};




class MTSuperClass multithreaded
{
  methods:
  external void threadMain();
};

class MultiThreadAdmin
{
   methods:      
   void turnOffLocking(&MTSuperClass* mtObject);
   void turnOnLocking(&MTSuperClass* mtObject);
};

class MutexInfo multithreaded
{
  inline_cpp[[
    #ifdef WIN32
      HANDLE _win_mutex;
    #else
      pthread_mutex_t* _pmutex;
    #endif
  ]]
methods:
    MutexInfo();
    external void threadMain(); 
};

class Mutex{
    MutexInfo* _mi;
    int _isOwner;
inline_cpp[[
    #ifdef WIN32
      HANDLE _win_mutex;
    #else
      pthread_mutex_t* _pmutex;
    #endif
]]
methods:
   Mutex();
   Mutex(MutexInfo* mi);
   void lock();
   void unlock();
   MutexInfo* getMutexInfo();
   ~Mutex();
};

class SemaphoreInfo multithreaded
{
  inline_cpp[[
    #ifdef WIN32
      HANDLE _win_sema;
    #else
      sem_t _sem_t;
    #endif
  ]]
methods:
    SemaphoreInfo();
    external void threadMain(); 
};

class Semaphore{
    SemaphoreInfo* _si;
    int _isOwner;
inline_cpp[[
    #ifdef WIN32
      HANDLE _win_sema;
    #else
      sem_t* _sem_t;
    #endif
]]
methods:
   Semaphore();
   Semaphore(SemaphoreInfo* si);
   void P();
   void V();
   SemaphoreInfo* getSemaphoreInfo();
   ~Semaphore();
};

class NullPtrClassSappeurInternal{
 methods:
};


class Input
{
methods:
   void getString(&String_16 str);
};

/* Klasse zum Umschalten der Benutzer-Nummer auf Unix-aehnlichen Rechnern.
   Dies ist oft aus Sicherheitsgruenden notwendig (oeffnen eines TCP/IP Ports
   kleiner 1024, danach umschalten von Benutzer root auf Anwender, mit
   wesentlich weniger Rechten/Eingriffsmoeglichkeiten
*/
class Benutzer_Umschalter
{
methods:
    void schalteNach(int benutzer,int gruppe);    
    void UnitTest();
};

